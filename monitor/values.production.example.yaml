# Production Values Example for kube-prometheus-stack
# Copy this file to values.production.yaml and customize for your production environment
# Usage: helm upgrade --install monitoring prometheus-community/kube-prometheus-stack -f values.production.yaml

# Global settings
global:
  rbac:
    create: true

prometheusOperator:
  enabled: true
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 200m
      memory: 256Mi

prometheus:
  enabled: true
  
  prometheusSpec:
    # Increase resources for production
    resources:
      requests:
        cpu: 500m
        memory: 1Gi
      limits:
        cpu: 1000m
        memory: 2Gi
    
    # Longer retention for production
    retention: 30d
    retentionSize: "45GB"
    
    # Larger storage for production
    storageSpec:
      volumeClaimTemplate:
        spec:
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 50Gi
          # Specify storage class for production
          # storageClassName: fast-ssd
    
    # Enable replicas for high availability
    replicas: 2
    
    # Anti-affinity to spread replicas across nodes
    affinity:
      podAntiAffinity:
        preferredDuringSchedulingIgnoredDuringExecution:
          - weight: 100
            podAffinityTerm:
              labelSelector:
                matchExpressions:
                  - key: app.kubernetes.io/name
                    operator: In
                    values:
                      - prometheus
              topologyKey: kubernetes.io/hostname
    
    serviceMonitorSelector:
      matchLabels:
        prometheus: monitoring
    
    podMonitorSelector:
      matchLabels:
        prometheus: monitoring
    
    # Enable remote write for long-term storage (optional)
    # remoteWrite:
    #   - url: "https://your-long-term-storage/api/v1/write"
    #     basicAuth:
    #       username:
    #         name: remote-write-secret
    #         key: username
    #       password:
    #         name: remote-write-secret
    #         key: password

grafana:
  enabled: true
  
  # Use existing secret (create a strong password!)
  admin:
    existingSecret: "grafana-admin-secret"
    userKey: admin-user
    passwordKey: admin-password
  
  # Increase resources for production
  resources:
    limits:
      cpu: 500m
      memory: 512Mi
    requests:
      cpu: 200m
      memory: 256Mi
  
  # Enable persistence with larger storage
  persistence:
    enabled: true
    type: pvc
    accessModes:
      - ReadWriteOnce
    size: 5Gi
    # Specify storage class
    # storageClassName: fast-ssd
  
  # Enable replicas for high availability
  replicas: 2
  
  # Ingress with TLS
  ingress:
    enabled: true
    ingressClassName: traefik
    annotations:
      traefik.ingress.kubernetes.io/router.entrypoints: websecure
      traefik.ingress.kubernetes.io/router.tls: "true"
      # Add cert-manager annotation if using it
      # cert-manager.io/cluster-issuer: "letsencrypt-prod"
    hosts:
      - grafana.yourdomain.com  # Change to your domain
    path: /
    pathType: Prefix
    # Enable TLS
    tls:
      - secretName: grafana-tls
        hosts:
          - grafana.yourdomain.com
  
  # Grafana configuration
  grafana.ini:
    server:
      root_url: https://grafana.yourdomain.com  # Change to your domain
      enforce_domain: true
    analytics:
      check_for_updates: false
      reporting_enabled: false
    security:
      allow_embedding: false
      cookie_secure: true
      cookie_samesite: strict
      strict_transport_security: true
      # Enable if you want to disable anonymous access
      # disable_gravatar: true
    users:
      auto_assign_org: true
      auto_assign_org_role: Viewer
      allow_sign_up: false  # Disable sign-up in production
    auth:
      disable_login_form: false
      # Enable OAuth if needed
      # oauth_auto_login: false
    auth.anonymous:
      enabled: false  # Disable anonymous access
    log:
      mode: console
      level: info
  
  defaultDashboardsEnabled: true
  defaultDashboardsTimezone: Asia/Bangkok
  
  datasources:
    datasources.yaml:
      apiVersion: 1
      datasources:
        - name: Prometheus
          type: prometheus
          url: http://monitoring-kube-prometheus-prometheus:9090
          access: proxy
          isDefault: true
          jsonData:
            timeInterval: 30s
            httpMethod: POST
  
  dashboardProviders:
    dashboardproviders.yaml:
      apiVersion: 1
      providers:
        - name: 'default'
          orgId: 1
          folder: ''
          type: file
          disableDeletion: false
          editable: true
          options:
            path: /var/lib/grafana/dashboards/default
        - name: 'backend'
          orgId: 1
          folder: 'Backend Monitoring'
          type: file
          disableDeletion: false
          editable: true
          options:
            path: /var/lib/grafana/dashboards/backend
  
  dashboards:
    backend: {}
  
  # SMTP configuration for email alerts (optional)
  # smtp:
  #   enabled: true
  #   host: smtp.gmail.com:587
  #   user: your-email@gmail.com
  #   password: your-app-password
  #   from_address: grafana@yourdomain.com
  #   from_name: Grafana

# Enable Alertmanager for production
alertmanager:
  enabled: true
  
  alertmanagerSpec:
    resources:
      requests:
        cpu: 100m
        memory: 128Mi
      limits:
        cpu: 200m
        memory: 256Mi
    
    storage:
      volumeClaimTemplate:
        spec:
          accessModes: ["ReadWriteOnce"]
          resources:
            requests:
              storage: 2Gi
    
    # Configure alertmanager (example)
    # config:
    #   global:
    #     resolve_timeout: 5m
    #   route:
    #     group_by: ['alertname', 'cluster', 'service']
    #     group_wait: 10s
    #     group_interval: 10s
    #     repeat_interval: 12h
    #     receiver: 'slack-notifications'
    #   receivers:
    #     - name: 'slack-notifications'
    #       slack_configs:
    #         - api_url: 'YOUR_SLACK_WEBHOOK_URL'
    #           channel: '#alerts'
    #           title: 'Alert: {{ .CommonLabels.alertname }}'
    #           text: '{{ range .Alerts }}{{ .Annotations.description }}{{ end }}'

nodeExporter:
  enabled: true
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

kubeStateMetrics:
  enabled: true
  resources:
    limits:
      cpu: 200m
      memory: 256Mi
    requests:
      cpu: 100m
      memory: 128Mi

# Enable Kubernetes components monitoring in production
coreDns:
  enabled: true

kubeDns:
  enabled: false

kubeControllerManager:
  enabled: true

kubeScheduler:
  enabled: true

kubeProxy:
  enabled: true

kubeEtcd:
  enabled: true

additionalServiceMonitors:
  - name: backend-servicemonitor
    namespaceSelector:
      matchNames:
        - superproject-ns
    selector:
      matchLabels:
        app: apartment-system
        component: backend
        monitoring: enabled
    endpoints:
      - port: http
        path: /actuator/prometheus
        interval: 30s
        scrapeTimeout: 10s
    labels:
      prometheus: monitoring

# Additional PrometheusRules for alerts (example)
# additionalPrometheusRules:
#   - name: backend-alerts
#     groups:
#       - name: backend
#         interval: 30s
#         rules:
#           - alert: HighErrorRate
#             expr: rate(http_server_requests_seconds_count{status=~"5.."}[5m]) > 0.1
#             for: 5m
#             labels:
#               severity: warning
#             annotations:
#               summary: "High error rate detected"
#               description: "Backend is experiencing {{ $value }} errors per second"
#           
#           - alert: HighMemoryUsage
#             expr: (jvm_memory_used_bytes{area="heap"} / jvm_memory_max_bytes{area="heap"}) > 0.9
#             for: 5m
#             labels:
#               severity: critical
#             annotations:
#               summary: "High memory usage"
#               description: "JVM heap memory usage is above 90%"
