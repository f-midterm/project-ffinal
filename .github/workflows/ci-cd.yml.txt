# This is a GitHub Actions workflow for Continuous Integration and Continuous Deployment (CI/CD).
# It automates testing, building, and deploying the application.

name: CI/CD Pipeline

# Controls when the workflow will run
on:
  push:
    branches: [ main, deploy ]
  pull_request:
    branches: [ main ]

# Environment variables available to all jobs in the workflow
env:
  DOCKER_REGISTRY: docker.io
  DOCKER_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
  DOCKER_PASSWORD: ${{ secrets.DOCKERHUB_TOKEN }}
  SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  SSH_USER: ${{ secrets.SSH_USER }}
  SERVER_HOST: ${{ secrets.SERVER_HOST }}

jobs:
  # This job runs the test suite for the backend application
  test:
    runs-on: ubuntu-latest
    name: Run Tests
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up JDK 21
      uses: actions/setup-java@v4
      with:
        java-version: '21'
        distribution: 'temurin'
        
    - name: Cache Gradle packages
      uses: actions/cache@v3
      with:
        path: |
          ~/.gradle/caches
          ~/.gradle/wrapper
        key: ${{ runner.os }}-gradle-${{ hashFiles('**/*.gradle*', '**/gradle-wrapper.properties') }}
        restore-keys: |
          ${{ runner.os }}-gradle-
          
    - name: Make gradlew executable
      run: chmod +x ./backend/gradlew
      
    - name: Test backend
      run: |
        cd backend
        ./gradlew test

  # This job builds the backend and frontend Docker images and pushes them to Docker Hub
  build-and-push:
    runs-on: ubuntu-latest
    name: Build and Push Docker Images
    needs: test
    # Define an output 'sha_tag' that the deploy job can use to reference the correct image tag
    outputs:
      sha_tag: ${{ github.sha }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ env.DOCKER_USERNAME }}
        password: ${{ env.DOCKER_PASSWORD }}

    # This action extracts metadata like tags and labels for the Docker images
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: |
          ${{ env.DOCKER_USERNAME }}/apartment-backend
          ${{ env.DOCKER_USERNAME }}/apartment-frontend
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=sha
          type=raw,value=latest,enable={{is_default_branch}}
          type=raw,value=develop,enable=${{ github.ref == 'refs/heads/develop' }}

    - name: Build and push backend image
      uses: docker/build-push-action@v5
      with:
        context: ./backend
        file: ./backend/Dockerfile
        push: true
        # Tags the image with the branch name and the full commit SHA
        tags: ${{ env.DOCKER_USERNAME }}/apartment-backend:${{ github.ref_name }},${{ env.DOCKER_USERNAME }}/apartment-backend:${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

    - name: Build and push frontend image
      uses: docker/build-push-action@v5
      with:
        context: ./frontend
        file: ./frontend/Dockerfile
        push: true
        # Tags the image with the branch name and the full commit SHA
        tags: ${{ env.DOCKER_USERNAME }}/apartment-frontend:${{ github.ref_name }},${{ env.DOCKER_USERNAME }}/apartment-frontend:${{ github.sha }}
        labels: ${{ steps.meta.outputs.labels }}
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # This job deploys the application to the server using Kubernetes
  deploy:
    name: Deploy to Server
    runs-on: self-hosted
    # FIX: Correctly depends on the 'build-and-push' job
    needs: build-and-push
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: ðŸ§¹ Teardown old environment
        run: |
          echo "--- Starting cleanup of old environment ---"
          kubectl delete namespace apartment-app --ignore-not-found=true
          kubectl delete pv mysql-pv --ignore-not-found=true
          kubectl delete -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/baremetal/deploy.yaml --ignore-not-found=true
          # Wait for resources to be fully terminated to avoid conflicts
          echo "Waiting for namespaces to be fully deleted..."
          sleep 30 
          echo "--- Cleanup complete ---"

      - name: ðŸš€ Deploy new environment
        run: |
          echo "--- Starting new deployment ---"
          
          # 1. Update image tags in Kubernetes manifests
          # FIX: Use the output from the 'build-and-push' job to get the correct commit SHA for the image tag
          echo "Updating image tags to commit ${{ needs.build-and-push.outputs.sha_tag }}"
          sed -i 's|image: .*apartment-backend.*|image: ${{ env.DOCKER_USERNAME }}/apartment-backend:${{ needs.build-and-push.outputs.sha_tag }}|g' k8s/05-backend.yaml
          sed -i 's|image: .*apartment-frontend.*|image: ${{ env.DOCKER_USERNAME }}/apartment-frontend:${{ needs.build-and-push.outputs.sha_tag }}|g' k8s/06-frontend.yaml
          
          # 2. Install Ingress Controller
          echo "Installing NGINX Ingress Controller..."
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/baremetal/deploy.yaml
          
          # 3. Wait for Ingress Controller to be ready
          echo "Waiting for Ingress Controller to be ready (up to 2 minutes)..."
          kubectl wait --namespace ingress-nginx \
            --for=condition=ready pod \
            --selector=app.kubernetes.io/component=controller \
            --timeout=120s
          echo "âœ… Ingress Controller is ready."

          # 4. Deploy the application resources defined in the k8s/ directory
          echo "Deploying application from k8s/ directory..."
          kubectl apply -f k8s/
          
          # 5. Wait for application pods to be ready to ensure a stable deployment
          echo "Waiting for application pods to be ready (up to 5 minutes)..."
          kubectl wait --namespace apartment-app \
            --for=condition=ready pod \
            --selector=app=mysql \
            --timeout=300s
          echo "âœ… MySQL pod is ready."

          kubectl wait --namespace apartment-app \
            --for=condition=ready pod \
            --selector=app=backend \
            --timeout=300s
          echo "âœ… Backend pods are ready."

          kubectl wait --namespace apartment-app \
            --for=condition=ready pod \
            --selector=app=frontend \
            --timeout=300s
          echo "âœ… Frontend pods are ready."

          echo "--- Deployment completed successfully! ---"

      - name: ðŸ“‹ Display Access Information
        run: |
          echo "--- Application Access Details ---"
          NODEPORT=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.spec.ports[?(@.name=="http")].nodePort}')
          SERVER_IP=$(hostname -I | awk '{print $1}')
          
          echo "âœ… Deployment is complete and application is running."
          echo "You can now access it using the permanent NodePort URL:"
          echo ""
          echo "   ðŸš€ http://${SERVER_IP}:${NODEPORT}"
          echo ""
          echo "This link works as long as your server is running. You do need to use 'kubectl port-forward'."
